## Vestigium
## https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27/000000000020993c
def vestigium(m,d):
    t,r,c=0,0,sum([1 if len(set(r))<d else 0 for r in zip(*m)])
    for i in range(d):
        r+=1 if len(set(m[i]))<d else 0
        for j in range(d):
            t+=m[i][j] if i==j else 0
    return ' '.join(map(str,[t,r,c]))
for i in range(1, int(input())+1):
    d,m=int(input()),[]
    for _ in range(d):
        m.append(list(map(int,input().split())))
    print("Case #{}: {}".format(i, vestigium(m,d)))

## Nesting Depth
## https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27/0000000000209a9f
def nesting_depth(s):
    c,r,s=0,'',list(map(int,s))
    for l in s:
        if l!=c:
            r+=("("if l>c else")")*abs(c-l)
        c,r=l,r+str(l)
    return r+")"*c
for i in range(1, int(input())+1):
    print("Case #{}: {}".format(i, nesting_depth(input())))

## Parenting Parenting
## https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27/000000000020bdf9
def parenting_partnering(t):
    c,j,ce,je,t=1,1,0,0,sorted([ t[i]+[i] for i in range(len(t))])
    for i in range(len(t)):
        if t[i][0] >= ce:
            c = 1
        if t[i][0] >= je:
            j = 1
        if c:
            t[i].append("C")
            c,ce = 0,t[i][1]
        elif j:
            t[i].append("J")
            j,je = 0,t[i][1]
        else:
            return "IMPOSSIBLE"
    return ''.join([i[3] for i in sorted(t,key=lambda x: x[2])]) 
for i in range(1, int(input())+1):
    print("Case #{}: {}".format(i, parenting_partnering([list(map(int, input().split())) for _ in range(int(input()))])))